#summary The page describes the concepts behind the Blackboard Event Processing System.
#labels Featured,Phase-Implementation

= Introduction =

The Blackboard Event Processor, or Blackboard for short, is a Java based implementation of the blackboard design paradigm. The blackboard design paradigm facilitates the organization of chunks of information for processing by loosely coupled software processes. These chunks of information are stored in the blackboard's central data repository. This central data repository is accessible by all participating software processes.

Software processes can add, update, and remove chunks of information in the repository. The blackboard design paradigm provides for data change notification services to the participating software processes, and provides for the scheduling of those software processes that wish to effect changes on the chunks of information in the repository. The diagram below illustrates the relationship among the data, software processes, and the blackboard in a hypothetical patient management application.

http://blackboardeventprocessor.googlecode.com/svn/trunk/src/doc/user/Blackboard_Model.jpg

The advantage of this design pattern is that it encourages the development of a loosely coupled programming structure. In addition, the blackboard design pattern also promotes contractual software process design. That is to say, software processes have the choice to subscribe to only the data changes they find interesting, or they may choose to proclaim disinterest in the current state of the blackboard, at which point their execution ends.

Consider the example patient application. Some of the activities supported by this application include “creating a new patient record”, “updating a patients diagnosis”, and “updating a patient's health status”. These activities will result in changes to the patient's data that is stored in the blackboard's data repository.

Other processes like “notify nurse” for instance, can subscribe to the patient's data changes committed by the other software processes. As an example, if the prescription of the patient changes, both the “notify patient” and the “notify nurse” processes would be interested in that, whereas if the patient slips into a coma, processes “notify nurse” and “notify next of kin” would be interested instead.

Using the blackboard model, programmers developing software focus on creating the following logic for each of the software processes they develop:

  * Logic that dictates the conditions for which the software process is interested in executing.
  * Logic that dictates the software process activity.
  * Logic that dictates the conditions for which the software process is no longer interested in executing.

Blackboard implements many of the ideas from the blackboard programming model. In Blackboard, chunks of information are called “targets”, and the software processes interested in these targets are called “plans”. There are also special types of targets called “events”. Events differ from ordinary targets in that they are typically created outside the blackboard environment. Finally, targets, plans, and events are all organized on the blackboard in “workspaces”.

A workspace is a logical division of the blackboard. The relationship amongst an event, its workspace, its associated plans, and the blackboard is similar to the relationship between a JMS message, a J2EE container, its associated message driven beans, and a J2EE application server, in the sense that many different types of workspaces can run on a single blackboard, and that the arrival of an event starts the execution plans on that workspace. The difference lies in the fact that workspaces are specifically geared to handle event based processing.

== High Level Blackboard Workspace Server Design ==
The following diagram illustrates the logical relationship of targets, events, plans, and the blackboard.

http://blackboardeventprocessor.googlecode.com/svn/trunk/src/doc/user/Blackboard_High_Level.jpg

In this diagram the large white oval represents the single blackboard. This blackboard supports three types of workspaces. Each type of workspace can support multiple instances, but for the purpose of this illustration only one instance of each workspace is shown. Targets are represented by circles, events by cylinders, and plans by hexagons. Targets, events, and plans are all named, and can be addressed by their names on the workspace2. For instance, in the “Music Order Workspace”, there are named targets, “T0” and “T1”, and named events “E0” and “E1”, and named plans “P0” and “P1”.

Whenever a target is retrieved by its name, the last instance of the target that was added to the workspace is retrieved, and the previous instance if lost to the workspace3. This differs from event retrieval where all versions of the named event added to the workspace are stored. This is why events are represented as a cylinder the diagram above.

===Blackboard===
Blackboard consists of a blackboard, workspaces, and plans. The blackboard is
responsible for managing the resources used by the server, and it serves as the gateway through which all events must pass through in order to arrive in workspace. In the general blackboard design paradigm, events are placed directly on the blackboard, however, Blackboard's implementation of the blackboard promotes the separation of the blackboard into smaller parts called workspaces. This allows for performance improvements, and it lends well to programmer organization of the software processes by attaching plans to workspaces of a particular name.

After instantiating a blackboard, placing an event on the blackboard is as easy as invoking the placeOnBlackboard(Object _object) method. The blackboard consults workspace configuration information to figure out what workspaces should be created for the object type placed. So conceivable one could defined workspaces to respond to the any of the types a particular class may have. For instance, if Customer extends the java.util.Object class, one could create workspaces in response to the Customer type and the Object type. This means the blackboard will create two workspaces every time it receives an object of class Person.

Additionally, the blackboard is responsible for persisting workspaces whenever they are retired, or whenever resource constraints called for temporary removal from memory.